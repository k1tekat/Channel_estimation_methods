# Методы оценки канала

*В работе проводится сравнительный анализ двух методов оценки канала связи, включая метод наименьших квадратов и метод, основанный на среднеквадратичном отклонении. Модуль оценки канала играет ключевую роль в обеспечении точности демодуляции принятых сигналов. Поскольку стандарты связи не регламентируют его реализацию, разработка эффективных алгоритмов оценки канала остается задачей производителей телекоммуникационного оборудования.*
## Описание Модели
Для выполнения сравнения двух методов оценки канала, необходим OFDM (Orthogonal frequency-division multiplexing) приемник и передатчик. Реализовано моделирование OFDM передатчика и приемника с использованием квадратурно амплитудной модуляцией QAM-16 (Quadrature amplitude modulation). Блок схема передатчика и приемника в системе OFDM:

![Блок схема передатчика и приемника](https://sun9-12.userapi.com/impg/XrQuYLaJD4HoWnzPpZWluVNw8H2QWLdUeqmmiA/_z5UL4C_i74.jpg?size=1280x795&quality=95&sign=7c894fbd6b4821cd91bb036778ef813a&type=album)

### Параметры системы
```

Nfft = 64  # Размер FFT
Ng = Nfft // 8  # Длина циклического префикса
Nofdm = Nfft + Ng  # Общая длина OFDM символа
Nsym = 1  # Количество OFDM символов 100 было
Nps = 8  # Интервал между пилотами
Np = Nfft // Nps  # Количество пилотов на OFDM символ
Nbps = 4  # Количество бит на символ
M = 2 ** Nbps  # Размер QAM модуляции
SNR = 30  # Отношение сигнал/шум в дБ
MSE = np.zeros(6)  # Массив для хранения MSE
nose = 0  # Счетчик ошибок
```


### Генерация битовой последовательности
```
Сгенерировать случайную битовую последовательность:

    bits = Случайная последовательность из 0 и 1,
           длина которой равна (Nfft - Np) * Nbps,
           где каждый бит независимо принимает значение 0 или 1 с вероятностью 0.5
```
Генерация происходит с учетом кол - ва свободных поднесущих, не занятых пилот сигналами.

Пример генерации битовой последовательности:  
![alt text](https://sun9-69.userapi.com/impg/K3qVU15G0GpoUxwEbojDv1TJOCz6usoWibE_7Q/qMZOuKr1jO0.jpg?size=599x125&quality=95&sign=fa22aad93904648e02e1db4b66a543b8&type=album)

### Mapper QAM-16
Задача Модулятора - закодировать группу из Npbs битов в один комплексный символ, где $$\log_2(16) = 4 = Npbs$$ и сформировать созвездие. В данной работе применяется QAM-16, Nbps прнимает значение равнрое 4
```
Mapper(битовая_последовательность b, битов_на_символ Nbps):

    Таблица_сопоставления:
        (0,0,0,0) → -3 - 3j
        (0,0,0,1) → -3 - 1j
        (0,0,1,0) → -3 + 3j
        (0,0,1,1) → -3 + 1j
        (0,1,0,0) → -1 - 3j
        (0,1,0,1) → -1 - 1j
        (0,1,1,0) → -1 + 3j
        (0,1,1,1) → -1 + 1j
        (1,0,0,0) →  3 - 3j
        (1,0,0,1) →  3 - 1j
        (1,0,1,0) →  3 + 3j
        (1,0,1,1) →  3 + 1j
        (1,1,0,0) →  1 - 3j
        (1,1,0,1) →  1 - 1j
        (1,1,1,0) →  1 + 3j
        (1,1,1,1) →  1 + 1j

    Если длина(b) % Nbps ≠ 0:
        Выбросить ошибку: "Длина битовой последовательности должна быть кратна Nbps"

    Количество_символов = длина(b) / Nbps
    Создать пустой массив N размером Количество_символов (тип — комплексные числа)

    Для каждого i от 0 до Количество_символов - 1:
        Начальный_индекс = i * Nbps
        Конечный_индекс = Начальный_индекс + Nbps
        Битовая_группа = b[Начальный_индекс : Конечный_индекс] как кортеж
        Символ_QAM = Таблица_сопоставления[Битовая_группа]
        N[i] = Символ_QAM

    Вернуть N
```
Пример создания созвездия:
![alt text](https://sun9-52.userapi.com/impg/_O9cUaE5t73yk5w3ZqywIoD-aYptW8309zgFmg/qry84gQi-HI.jpg?size=1582x838&quality=95&sign=a4b81cee7d3393edf7a2c2f2df6e4508&type=album)

Выходные данные после модуляции:    
![alt text](https://sun9-59.userapi.com/impg/kuL_cXkjtlIEWe0l1K1G4FH5HWF-wMyyLBgdiQ/YP4uexrtSfg.jpg?size=359x267&quality=95&sign=833945979070f45a65d0c37944ebb13a&type=album)


### Формирование OFDM символа
OFDM символ формируется из поднесущих с данными и поднесущих с пилот сигналами. В параметрах системы настраивается кол-во пилот сигналов и частота рассиановки.

```
Формирование OFDM-символа X длиной Nfft:

    Инициализировать массив X размером Nfft, заполнить нулями (комплексные числа)
    Установить ip = 0     // индекс текущего пилотного символа в массиве Xp
    Установить buf = 0    // счётчик тактов между пилотами
    Создать список pilot_loc — для хранения позиций пилотных поднесущих

    Для каждого номера поднесущей k от 0 до Nfft - 1:

        Если buf равен 0:
            Добавить Xp[ip] на позицию k в массиве X
            Добавить k в список pilot_loc
            Увеличить ip на 1
            Установить buf = Nps   // интервал между пилотами
        Иначе:
            Добавить My_Data[1] на позицию k в массиве X
            Уменьшить buf на 1

    Вернуть X и массив pilot_loc
```
Пример сгенерированного OFDM символа:
![](https://sun9-78.userapi.com/impg/0eOVbkPmsBZZOk54ZZvjLTQCEM2UlrhjakHoBA/KIu-vVCifhA.jpg?size=358x272&quality=95&sign=b2c2ae4ac6e2988f50ff4e4f5dfefa69&type=album)

### IFFT & FFT
#### IFFT
```
1. Обратное БПФ: переводим сигнал из частотной области во временную
x = IFFT(X)
```
Пример преобразования сигнала:
![](https://sun9-80.userapi.com/impg/XkwNn8A0mr6JYsLeNp5A3mJKy0VQ_GIRdYrDZA/0ZDNhUctWAQ.jpg?size=1887x246&quality=95&sign=6fd057e169d95c3d164cd6621364f6fe&type=album)
![](https://sun9-43.userapi.com/impg/G7P9j89mDMGpfFSthsrf5yoIbDvANVa4WFvphw/gqZ03cTwJ1E.jpg?size=1884x216&quality=95&sign=c95c722812b1a9529be93660f1d1958b&type=album)
#### FFT
```
// y — принятый сигнал во временной области (после удаления CP)
// Y — результат FFT: сигнал в частотной области

Y = FFT(y)
```
Принятый сигнал после FFT, с шумом и искажением от канала:
![](https://sun9-56.userapi.com/impg/cLqxl5snkPg8Vy6L7OdtXI24_L62NerIlH13Pw/QMfa3zkpHvw.jpg?size=1879x229&quality=95&sign=eb88471b9f4a92f63d6b2e5bff597d36&type=album)
### Добавление и удаление CP
### Канал передачи
Беспроводной канал передачи — это среда распространения радиосигнала между передатчиком и приёмником. Он обладает рядом физических эффектов, таких как: многолучевость, затухание, шум и помехи, которые могут существенно исказить сигнал.

```
Генерация случайного беспроводного канала:

    // Генерируем импульсный отклик 2ух лучевого канала h (2 отсчёта)
    h = Комплексный вектор длины 2, где:
        Реальная часть = случайные числа из нормального распределения
        Мнименная часть = случайные числа из нормального распределения

    // Преобразуем канал в частотную область с помощью FFT
    H_true = FFT(h, размером Nfft)

    // Сохраняем длину импульсного отклика канала
    ch_length = Длина вектора h
```
Пример сгенерированного канала:
![alt text](https://sun9-38.userapi.com/impg/O8uG67DP_8FryPuYs6hx7UjtxwFZ4ye-_I1MGw/kjLEx_VvJC0.jpg?size=1871x923&quality=95&sign=677e7be6da9be5d76e093630dea5235c&type=album)

```
Прохождение сигнала через канал:

    // xt — переданный OFDM-символ (во временной области)
    // h — импульсный отклик канала (во временной области)

    // 1. Свёртка сигнала с каналом
    y_channel = полная свёртка xt и h

    // 2. Обрезка до длины Nofdm
    y_channel = y_channel[0 : Nofdm]

    // 3. Добавление белого гауссовского шума (AWGN) с заданным SNR
    yt = y_channel + AWGN_шум(SNR)

    // 4. Удаление циклического префикса (CP)
    y = yt[Ng : ]  // Ng — длина циклического префикса

    // 5. Переход в частотную область с помощью БПФ
    Y = Быстрое преобразование Фурье(y)
```

Пример входных и выходных данных:
![alt text](https://sun9-8.userapi.com/impg/wWCpPF-sZBxdH_IfrrIim5A3sZ2sLwdYhGNUGg/CCtEixkQ1Lc.jpg?size=1870x886&quality=95&sign=61a2480f11c58400fe3f73a49d496708&type=album)



### Оценка канала
Для оценки канала можно использовать обучающие символы, которые обычно обеспечивают хорошую производительность. 
Однако эффективность их передачи снижается из-за дополнительных затрат на обучающие символы, такие как преамбула или пилотные тона, которые передаются в дополнение к символам данных.  Для оценки канала при наличии обучающих символов широко используются методы наименьших квадратов (LS) и минимальной среднеквадратичной ошибки (MMSE). 
Мы предполагаем, что все поднесущие являются ортогональными (т. е. не содержат межсимвольных интерференций). Тогда обучающие символы для N поднесущих могут быть представлены в виде следующей диагональной матрицы:

Матрица X представляет собой диагональную матрицу размерности N×N, где каждый элемент на диагонали x[k] соответствует пилотному символу k-й поднесущей. Размерность матрицы зависит от количества поднесущих N.

```math
\mathbf{X} =  
 \begin{vmatrix}
 \mathbf{X[0]} & 0 & \mathbf{ \cdots }& 0
 \\0 & X[1] &  & \vdots
 \\\vdots & & \ddots & 0
 \\ 0 & \cdots & 0 & X[N-1]
 \end{vmatrix} 
```

где
```math 
X[k]
```
 точка пилот сигнала k-й поднесущей, с мат. ожиданием:
```math
\mathbb{E}\{X[k]\} = 0
```
и дисперсией:
```math
\mathrm{Var} {X[k] } =  \sigma_x^2 , ( k = 0, 1, 2, \dots, N-1 )


```
Пример вывода: 
X = ![Диагональная матрица](https://sun9-68.userapi.com/impg/hF9NLhbc2302DNsYCsfiHNU9VhGJjY1lW9dPjg/jwaDA9dlAqA.jpg?size=313x266&quality=95&sign=37d89592e40e921ba367364d278f4168&type=album)


Обратите внимание, что X задаётся диагональной матрицей, поскольку мы предполагаем, что все поднесущие являются ортогональными. Учитывая, что коэффициент влияния канала H[k] для каждой поднесущей k, принятый обучающий сигнал Y[k] можно представить в виде
```math
Y \triangleq 
\begin{bmatrix}
Y[0] \\
Y[1] \\
\vdots \\
Y[N-1]
\end{bmatrix} = 
\begin{bmatrix}
X[0] & 0 & \cdots & 0 \\
0 & X[1] & \ddots & \vdots \\
\vdots & \ddots & \ddots & 0 \\
0 & \cdots & 0 & X[N-1]
\end{bmatrix}
\begin{bmatrix}
H[0] \\
H[1] \\
\vdots \\
H[N-1]
\end{bmatrix} + 
\begin{bmatrix}
Z[0] \\
Z[1] \\
\vdots \\
Z[N-1]
\end{bmatrix}
= XH + Z (6.3)

```
где H - вектор канала, заданный в виде 
```math
H = [H[0], H[1], \dots, H[N-1]]^T 
```
а Z - это вектор шума, заданный как
```math
Z = [Z[0], Z[1], \dots, Z[N-1]]^T
```
вместе с мат. ожиданием:
```math
\mathbb{E}\{Z[k]\} = 0
```
и дисперсией:
```math
\mathrm{Var}\{Z[k]\} = \sigma_z^2,( k = 0, 1, 2, \dots, N-1).
```
Получается, что принятый сигнал Y, это произведение значений влияния канала на значения пилотных сигналов + шум.
На основе изветных значений пилот сигналов, можно вычислить не известные значения влияния канала.
В дальнейшем, 
```math
\hat{H}
```
обозначим как оценку канала H.


# Методы оценки канала 


### Метод наименьших квадратов (МНК)
Метод наименьших квадратов для оценки канала находит оценку канала 
```math
\hat{H}
```
таким образом,чтобы минимизировать следующую функцию стоимости:

```math
\begin{aligned}
J(\hat{H}) &= \|Y - X\hat{H}\|^2 \\
&= (Y - X\hat{H})^H (Y - X\hat{H}) \\
&= Y^H Y - Y^H X \hat{H} - \hat{H}^H X^H Y + \hat{H}^H X^H X \hat{H}
\end{aligned} (6.4)
```
Приравниваем производную функции к нулю:

$$
\frac{\partial J(\mathbf{\hat{H}})}{\partial \mathbf{\hat{H}}} = -2(\mathbf{X}^H \mathbf{Y})^* + 2(\mathbf{X}^H \mathbf{X} \mathbf{H})^* = 0 (6.5)
$$
и получаем: $$ \mathbf{X}^H \mathbf{X} \hat{\mathbf{H}} = \mathbf{X}^H \mathbf{Y},$$

что даёт решение для оценки канала методом наименьших квадратов в виде:

$$
\hat{\mathbf{H}}_{LS} = (\mathbf{X}^H \mathbf{X})^{-1} \mathbf{X}^H \mathbf{Y} = \mathbf{X}^{-1} \mathbf{Y} (6.6)
$$

$$\hat{H}_{LS}[k] = \frac{Y[k]}{X[k]}, \quad k = 0, 1, 2, \ldots, N-1 (6.7)$$

```
Функция LS_CE(Y, Xp, pilot_loc, Nfft, Nps, int_opt):

    // Y — принятый сигнал в частотной области
    // Xp — переданные пилотные символы
    // pilot_loc — массив индексов поднесущих с пилотами
    // Nfft — общее количество поднесущих
    // Nps — шаг между пилотными поднесущими
    // int_opt — тип интерполяции ('linear' или 'spline')

    // 1. Вычисляем количество пилотных поднесущих
    Np = Nfft / Nps

    // 2. Оценка канала в местах пилотов: деление принятого сигнала на известный
    H_pilot = Y[pilot_loc[0:Np]] / Xp[0:Np] (6.7)

    // 3. Выбираем метод интерполяции
    Если int_opt начинается с 'l':
        method = 'linear'
    Иначе:
        method = 'spline'

    // 4. Интерполируем оценку канала на все поднесущие
    H_LS = Интерполировать(H_pilot, pilot_loc[0:Np], Nfft, method)

    // 5. Возвращаем оценку канала для всех поднесущих
    Вернуть H_LS
```
### Метод минимизации среднеквадратичной ошибки (МСКО)





















